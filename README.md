# Lifecycle-Models

## Spiral Lifecycle Model
#### The Spiral lifecycle model is an example of a risk-driven model. This means that the success of a project depends on how well risk analysis is carried out. Analysis is the process of estimating and monitoring the probability of completing technical challenges in your project and to account for other possible issues such as cost increases. In the spiral lifecycle model, the higher the risk is deemed to be, the more effort it places on completing that task.
#### The Spiral model is best used on very large projects with ever changing tasks and challenges that will require new versions of the project to be constantly rolled out. An example of this is the development of operating systems such as iOS, as new versions are required to be released and tested regularly. 
![model](https://github.com/kap14275819/Lifecycle-Models/blob/master/spiral.png)
### Risks
#### Risks are possible conditions and events that prevent the development team from its goals. Thereâ€™s a wide range of them, from trivial to fatal. To have all these risks managed in the Spial model, the first primary task to be done is to make sure all possible risks are mentioned and then prioritise them according to importance. Afterwards the next will be to then make sure any potential strategies that will be able to help overcome the risks. Evaluation of these parameters can cause changes at the next steps. And then at the end of this stage, a prototype is produced.

## V-model(Sequential)
#### In software development, the V-model is represented by a development process that is considered to be an extension fo the waterfall model, and is an example of the more general V-model. The V-Model determines the relationship between each of the phases in the development lifecycle and its associated phase of testing. The model focuses on a fairly typical waterfall method that follows strict, step-by-step stages. While initial stages are broad design stages, progress proceeds down through more and more granular stages, leading into implementation and coding, and finally back through all testing stages prior to completion of the project.

#### Similar to the traditional waterfall model, the V-Model specifies a series of linear stages that should occur across the life cycle, one at a time, until the project is complete. For this reason V-Model is not considered an agile development method, and due to the sheer volume of stages and their integration, understanding the model in detail can be challenging for everyone on the team, let alone clients or users. Instead of moving down in a linear way, the process steps are bent upwards after the coding phase, to form the typical V shape.


## Waterfall Model(Sequential)
#### The waterfall model is a popular version of the systems development life cycle model for software engineering. Often considered the classic approach to the systems development life cycle, the waterfall model describes a development method that is linear and sequential. Waterfall development has distinct goals for each phase of development. Imagine a waterfall on the cliff of a steep mountain. Once the water has flowed over the edge of the cliff and has begun its journey down the side of the mountain, it cannot turn back. It is the same with waterfall development. Once a phase of development is completed, the development proceeds to the next phase and there is no turning back.

## Evolutionary Model(iterative)
#### This model is the idea of developing an initial software idea from very broad specifications. Each version of you make will inherit the best features from earlier versions. Each version is changed based upon feedback from yourself or your team members to produce a system which meets the clients needs. At this point the system may be delivered. Development and validation are done at the same time with feedback between each.

## Prototype Model(iterative)
#### The idea of the Prototype model is that instead of defining the requirements before a design or coding can proceed, a disposable prototype is built to understand the requirements. This idea in this prototype are then developed further as requirements are understood and mapped out.

## Feasibility Report
#### A feasibility report is designed to present the individual challenges in a project and talk about any potential solutions to these challenges. When potential solutions are presented, they are expanded upon in depth to explain exactly how this would solve the problem. Once a solution is agreed upon, it is sent to the project manager for authorization.

### A Feasibility report will contain the following:
#### Proposed Project Description

##### This segment is for essentially describing the project that is being worked on and goes into detail about the time constraints and how much the project will cost, not only money but in terms of manpower too.

#### Market Analysis Section
##### This section looks at the market that the current project will be targeted at. Detailing the size of the market and its demographic using available data or by completing surveys. This is done to determine if a venture into this market will be profitable.

#### Technical Feasibility Section
##### Technical Feasibility covers the ability to complete the programming and other technical challenges

#### Financial Feasibility Section
##### The Financial Feasibility section talks about any costs that come with the project and if the venture is profitable, this can include costs of software, staff payments and bills.

## How Can Technical Solutions Be Compared
### Technical solutions can be compared based on the following factors: 
#### Fitness: Does the technology address the problem at hand, or is it being used for an unintended purpose?

#### Maturity: It's risky to use version 1.0 of anything. Both hardware and software companies are frequently pressed to release products before they are ready.

#### Support: If something goes wrong, who/how many people can help solve the problem? While commercial (paid) support is appreciated, open-source products with large numbers of helpful users can be even more valuable.

#### Reliability/availability/scalability: Does the technology support the required usage volume? Does it offer fail-over mechanisms for high availability?

#### License and support costs: What are the one-time and annual costs of using a technology? While my developers might have a fondness for certain proprietary software, is there an adequate free or low-cost open-source alternative? Keep in mind that even open-source software can be expensive if the vendor restricts commercial use or has inconvenient licensing terms.

## CMM
#### The Capability Maturity Model (CMM) is a methodology used to develop and refine an organization's software development process. The model describes a five-level evolutionary path of increasingly organized and systematically more mature processes. CMM was developed and is promoted by the Software Engineering Institute (SEI), a research and development center sponsored by the U.S. Department of Defence (DoD). 
#### The CMM is similar to ISO 9001, one of the ISO 9000 series of standards specified by the International Organization for Standardization (ISO). The ISO 9000 standards specify an effective quality system for manufacturing and service industries; ISO 9001 deals specifically with software development and maintenance. The main difference between the two systems lies in their respective purposes: ISO 9001 specifies a minimal acceptable quality level for software processes, while the CMM establishes a framework for continuous process improvement and is more explicit than the ISO standard in defining the means to be employed to that end.
### CMM's Five Maturity Levels of Software Processes:
#### At the initial level, processes are disorganized, even chaotic. Success is likely to depend on individual efforts, and is not considered to be repeatable, because processes would not be sufficiently defined and documented to allow them to be replicated.
#### At the repeatable level, basic project management techniques are established, and successes could be repeated, because the requisite processes would have been made established, defined, and documented.
#### At the defined level, an organization has developed its own standard software process through greater attention to documentation, standardization, and integration.
#### At the managed level, an organization monitors and controls its own processes through data collection and analysis.
#### At the optimizing level, processes are constantly being improved through monitoring feedback from current processes and introducing innovative processes to better serve the organization's particular needs.

